* 인덱스란 >

전체 내용물 중에서 특정한 부분을 바로 찾을 수 있는 목차나 색인의 개념.  (데이터가 정렬되어 있는 주소 값을 저장하고 있는 object)



* 인덱스의 특징 >
- 일반적인 테이블과 달리 인덱스는 정렬되어 있다.

- 전체 데이터에서 적은양의 데이터를 검색할 때 index 를 사용한다.

(전체 테이블의 10~15% 를 넘지 않아야 인덱스로서의 가치가 있다는 설명을 관련서적에서 본적이 있을 것이다.

이 말은 10~15% 이상인 경우 차라리 전체 테이블을 스캔하는 것이 유리하다는 것을 의미한다. 왜냐하면 인덱스를 경유하여

엑세스 하는 일은 처리할 범위의 인덱스 row에 있는 rowid 정보를 이용해 실제 테이블에 있는 row를 일일이 랜덤하게 엑세스해야 하므로 스캔방식보다 훨씬 불리하기 때문이다. )

- 성능향상 조건:   I/O 과 wait(=지연시간) 을 낮추는 것이다.


* 인덱스를 사용하지 못하는 경우 >

첫번째, LIKE 검색시 좌변에 %를 붙일 경우

  WHERE DEPT LIKE '%111' : 인덱스 사용 불가
  WHERE DEPT LIKE '111%' : 인덱스 사용 가능
  좌변에 %를 붙일경우 인덱스를 참조 하지 못하게 된다. 왜냐하면 인덱스란 해당되는 컬럼의 값과 주소를 저장하는 리스트를 반드시 정렬해서 저장해놓는 색인과도 같은 것인데 시작되는 값이 먼지 모르고 끝나는 값만으로 인덱스를 참조하기 불가능한것이다. 이는 마치 영어사전에서 ABC로 시작하는 단어를 찾으라 하면 쉽게 찾는 반면 ABC로 끝나는 단어를 찾으라그러면 어떻게 찾아야 될지 모르는 것과도 같은 상황인것이다.

예제>
<인덱스를 사용하는 경우>
-쿼리-
select * from index_table
where name like '김동%';
-실행계획-


<인덱스를 사용하지 못하는 경우>
-쿼리-
select * from index_table
where name like '%동현';
-실행계획-



두번째, IS NULL이나 IS NOT NULL을 사용할경우

<< B-tree Index Entry Structure >>

Header

Column Length

Column Value

Column Length

Column Value

RowId

- Entry Header : 컬럼의 수와 Lock 정보를 저장한다.

- Key Column Length : 컬럼의 길이를 정의한다.

- Key column Value : 컬럼의 값을 정의한다.

- ROWID : Row의 위치정보를 저장한다.


> IS NULL의 경우, null 은 value는 들어가지 않는다.



Header

Length

Test1

Length

Test2

Length

Length

.
.

<?xml:namespace prefix = o />.



> IS NOT NULL 경우, 인덱스는 null 이 없으므로 실행계획은 full scan 을 실행한다. 따라서 적은 양의 데이터가 아니라면 인덱스를 사용했을 때 더 느려질 수 있다.


예제>
-쿼리-
select * from index_table
where name is null;
-실행계획-


세번째, 인덱스로 지정된 칼럼이 가공되거나 변형된 경우

  WHERE SUBSTR(CODE, 2,3)
  WHERE COL1*2 > 200
  위와 같이 SUBSTR을 사용한 경우 문자열의 중간 부분을 떼어 내어 인덱스와 비교해야되기 때문에 첫번째 LIKE검색시의 경우와 동일한 경우라고 볼 수 있다. 두번째의 경우에는 인덱스로 지정된 칼럼의 값이 변형되었기 때문에 인덱스를 사용하지 못하게 된다.
예제>
-쿼리-
select * from index_table
where substr(name,2,3) ='청하';
-실행계획-



네번째, 부정연산자(!=, <>)를 사용하는 경우

  인덱스로 자료를 찾는 경우에는 결과의 값이 적을 경우 빠르게 찾게 도와주는 반면 부정연산자를 사용하는 경우에는 소수의 결과가 아닌 더 넓은 범위의 결과를 찾기 때문에 인덱스를 사용하지 않고 테이블을 풀스캔하게 된다.
예제>
-쿼리-
select * from index_table
where name != '류청하';
-실행계획-



<예제 sql>
create table index_table(
 name varchar2(50),
 hp varchar2(50)
);
create index i_name on index_table(name);

다섯번째, 암시적인 형변환

암시적 형 변환이 일어 날 경우 인덱스 컬럼이 가공이 되냐? 비교 데이터가 변경이 되냐? 에 따라서 인덱스를 사용할 수도 안할 수도 있다.



where 조건 절에 비교 컬럼 타입이 틀릴 때

- (숫자와 문자 비교) : where detpno = to_number('10')

- (날짜와 문자 비교) : where  to_char(date) Like '90%'

- (값이 입력될 때) : where deptno : 1

프로시저 입력되는 임의 값이 현재 컬럼의 형식과 다른 형식으로 선언되어 들어온다면,  어느 한쪽이든 형변환이 필요하다. 데이터 타입의 우선순위는 입력된 값의 형식을 우선 따르기 때문에 데이터의 컬럼의 가공이 일어난다.

[출처] 인덱스를 사용하지 못하는 경우 (Oracle University (Korea))
